/*
 * Copyright 2023 RAW Labs S.A.
 *
 * Use of this software is governed by the Business Source License
 * included in the file licenses/BSL.txt.
 *
 * As of the Change Date specified in that file, in accordance with
 * the Business Source License, use of this software will be governed
 * by the Apache License, Version 2.0, included in the file
 * licenses/APL.txt.
 */

///*
// * This file is part of Kiama.
// *
// * Copyright (C) 2014-2017 Anthony M Sloane, Macquarie University.
// *
// * This Source Code Form is subject to the terms of the Mozilla Public
// * License, v. 2.0. If a copy of the MPL was not distributed with this
// * file, You can obtain one at http://mozilla.org/MPL/2.0/.
// */
//
//package org.bitbucket.inkytonik.kiama
//package relation
//
//import java.util
//
//import org.bitbucket.inkytonik.kiama.relation.Relation.emptyImage
//import org.bitbucket.inkytonik.kiama.util.Memoiser
//import org.bitbucket.inkytonik.kiama.util.Memoiser.makeIdMemoiser
//
//
///**
//  * A tree relation is a binary relation on tree nodes with an extra property
//  * that the `image` operation throws a `NodeNotInTreeException` exception if
//  * it is applied to a node that is not in this tree. `T` is the type of the
//  * tree nodes.
//  */
//class TreeRelation[T <: Product](
//                                  tree: Tree[T, _ <: T],
//                                  override val graph: Memoiser[T, Vector[T]] = makeIdMemoiser[T, Vector[T]](),
//                                  override val inverseGraph: Memoiser[T, Vector[T]] = makeIdMemoiser[T, Vector[T]]()
//                                ) extends Relation[T, T](graph, inverseGraph) {
//
//  rel =>
//
//  // Make sure root is present
//  graph.putIfAbsent(tree.root, emptyImage)
//  inverseGraph.putIfAbsent(tree.root, emptyImage)
//
//  /**
//    * Set the image of the relation for `t` to `us`. Takes care to make
//    * sure that all mentioned nodes are present in the graph and the
//    * inverse graph.
//    */
//  def set(t: T, us: Vector[T]) {
//    // MONKEY PATCH (ns): avoid object creation from using immutable data structures for queues and stacks
//    //    graph.updateAt(t, _ ++ us, us)
//    //    for (u <- us)
//    //      graph.putIfAbsent(u, emptyImage)
//    //    inverseGraph.putIfAbsent(t, emptyImage)
//    //    for (u <- us)
//    //      inverseGraph.updateAt(u, _ :+ t, Vector(t))
//
//    graph.updateAt(t, _ ++ us, us)
//    inverseGraph.putIfAbsent(t, emptyImage)
//    // Avoid creating a VectorIterator object (in the foreach generated by the Scala for)
//    //    for (u <- us)
//    //      graph.putIfAbsent(u, emptyImage)
//    var i = 0
//    while (i < us.length) {
//      val u = us(i)
//      graph.putIfAbsent(u, emptyImage)
//      inverseGraph.updateAt(u, _ :+ t, Vector(t))
//      i += 1
//    }
//  }
//
//
//  override def apply(t: T): Vector[T] = {
//    val v = super.getGraph(t)
//    if (v == null)
//      throw new NodeNotInTreeException(t)
//    else
//      v
//  }
//
//  override lazy val inverse: TreeRelation[T] =
//    new TreeRelation[T](tree, inverseGraph, graph) {
//      override lazy val inverse: TreeRelation[T] =
//        rel
//    }
//
//}
//
///**
//  * Support for tree relations.
//  */
//object TreeRelation {
//
//  import scala.annotation.tailrec
//
//  /**
//    * Return whether this node is a leaf node or not.
//    */
//  def isLeaf[T <: Product](t: T): Boolean = {
//    // Avoid the NonLocalControlReturn exception cause by using return inside a closure
//    //    for (desc <- t.productIterator) {
//    //      desc match {
//    //        case _ : Option[_] | _ : Either[_, _] | _ : Tuple1[_] |
//    //             _ : Tuple2[_, _] | _ : Tuple3[_, _, _] | _ : Tuple4[_, _, _, _] =>
//    //        // Do nothing
//    //        case _ : Product =>
//    //          return false
//    //        case _ =>
//    //        // Do nothing
//    //      }
//    //    }
//    //    true
//    val iter = t.productIterator
//    var retValue = true
//    while (retValue && iter.hasNext) {
//      iter.next() match {
//        case _: Option[_] | _: Either[_, _] | _: Tuple1[_] | _: Tuple2[_, _] | _: Tuple3[_, _, _] | _: Tuple4[_, _, _, _] =>
//        // Do nothing
//        case _: Product =>
//          retValue = false
//        case _ =>
//        // Do nothing
//      }
//    }
//    retValue
//  }
//
//
//  // (ns) The scala Queue is immutable and this loop is removing and adding elements frequently,
//  // which causes allocation of many object. Convert to using a mutable datastructure.
//
//  //  def treeChildren[T <: Product](t : T) : Vector[T] = {
//  //
//  //    @tailrec
//  //    def loop(pending : Queue[Any], children : Vector[T]) : Vector[T] =
//  //      if (pending.isEmpty)
//  //        children
//  //      else {
//  //        val candidate = pending.front
//  //        val rest = pending.tail
//  //        candidate match {
//  //          case _ : Bridge[_] =>
//  //            // ignore
//  //            loop(rest, children)
//  //
//  //          case Some(n) =>
//  //            loop(n +: rest, children)
//  //          case None =>
//  //            // ignore
//  //            loop(rest, children)
//  //
//  //          case Left(l) =>
//  //            loop(l +: rest, children)
//  //          case Right(r) =>
//  //            loop(r +: rest, children)
//  //
//  //          case Tuple1(a) =>
//  //            loop(a +: rest, children)
//  //          case (a, b) =>
//  //            loop(List(a, b) ++: rest, children)
//  //          case (a, b, c) =>
//  //            loop(List(a, b, c) ++: rest, children)
//  //          case (a, b, c, d) =>
//  //            loop(List(a, b, c, d) ++: rest, children)
//  //
//  //          case s : TraversableOnce[_] =>
//  //            loop(s ++: rest, children)
//  //
//  //          case p : Product =>
//  //            loop(rest, children :+ (p.asInstanceOf[T]))
//  //
//  //          case _ =>
//  //            // ignore
//  //            loop(rest, children)
//  //        }
//  //      }
//  //
//  //    loop(Queue(t.productIterator), emptyImage)
//  //
//  //  }
//
//  def treeChildren[T <: Product](t: T): Vector[T] = {
//    // (ns) Not necessary to convert to iteration, the scala compiler is generating a non-recursive
//    // implementation (confirmed by looking at the generated bytecode)
//
//    // (ns) Using a Java collection because Scala 2.12 does not have an efficient Stack implementation,
//    // it is just a wrapper over an immutable List, so has no performance benefits over the Kiama implementation.
//    // Scala 2.13 has an efficient Stack implementation, similar to the Java one.
//    @tailrec
//    def loop(stack: util.ArrayDeque[Any], children: Vector[T]): Vector[T] =
//
//      if (stack.isEmpty)
//        children
//      else {
//        val candidate = stack.pop()
//        candidate match {
//          case _: Bridge[_] =>
//            // ignore
//            loop(stack, children)
//
//          case Some(n) =>
//            stack.addFirst(n)
//            loop(stack, children)
//          case None =>
//            // ignore
//            loop(stack, children)
//
//          case Left(l) =>
//            stack.addFirst(l)
//            loop(stack, children)
//          case Right(r) =>
//            stack.addFirst(r)
//            loop(stack, children)
//
//          case Tuple1(a) =>
//            stack.addFirst(a)
//            loop(stack, children)
//          case (a, b) =>
//            stack.addFirst(b)
//            stack.addFirst(a)
//            loop(stack, children)
//          case (a, b, c) =>
//            stack.addFirst(c)
//            stack.addFirst(b)
//            stack.addFirst(a)
//            loop(stack, children)
//          case (a, b, c, d) =>
//            stack.addFirst(d)
//            stack.addFirst(c)
//            stack.addFirst(b)
//            stack.addFirst(a)
//            loop(stack, children)
//
//          case s: TraversableOnce[_] =>
//            s.toList.reverse.iterator.foreach(
//              stack.addFirst(_)
//            )
//            loop(stack, children)
//
//          case p: Product =>
//            loop(stack, children :+ (p.asInstanceOf[T]))
//
//          case _ =>
//            // ignore
//            loop(stack, children)
//        }
//      }
//
//    val stack = new util.ArrayDeque[Any](t.productArity)
//    t.productIterator.foreach {
//      stack.addLast(_)
//    }
//    loop(stack, emptyImage)
//
//  }
//
//  /**
//    * Make a child tree relation for the given tree. Populate the relation
//    * using `treeChildren` to traverse the structure from the tree's root.
//    */
//  //  def childFromTree[T <: Product, R <: T](tree: Tree[T, R]): TreeRelation[T] = {
//  //
//  //    val relation = new TreeRelation(tree)
//  //
//  //    @tailrec
//  //    def loop(pending: Queue[T]): TreeRelation[T] =
//  //      if (pending.isEmpty)
//  //        relation
//  //      else {
//  //        val l = pending.front
//  //        val next = treeChildren(l)
//  //        if (!next.isEmpty)
//  //          relation.set(l, next)
//  //        loop(pending.tail.enqueue(next))
//  //      }
//  //
//  //    loop(Queue(tree.root))
//  //
//  //  }
//  //
//  def childFromTree[T <: Product, R <: T](tree: Tree[T, R]): TreeRelation[T] = {
//
//    val relation = new TreeRelation(tree)
//
//    @tailrec
//    def loop(pending: util.ArrayDeque[T]): TreeRelation[T] =
//      if (pending.isEmpty)
//        relation
//      else {
//        val l = pending.removeFirst()
//        val next = treeChildren(l)
//        if (!next.isEmpty)
//          relation.set(l, next)
//
//        var i = 0
//        while (i < next.length) {
//          pending.addLast(next(i))
//          i += 1
//        }
//        loop(pending)
//      }
//
//    val queue = new util.ArrayDeque[T]()
//    queue.add(tree.root)
//    loop(queue)
//
//  }
//
//}
